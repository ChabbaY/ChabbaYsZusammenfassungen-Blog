import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as n,d as i,a as r,o as l}from"./app-CEbH5TK9.js";const a={},o={class:"MathJax",jax:"SVG",style:{position:"relative"}},u={style:{"vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.181ex",role:"img",focusable:"false",viewBox:"0 -511 1000 522","aria-hidden":"true"},g={class:"MathJax",jax:"SVG",style:{position:"relative"}},d={style:{"vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.181ex",role:"img",focusable:"false",viewBox:"0 -511 1000 522","aria-hidden":"true"},h={class:"MathJax",jax:"SVG",style:{position:"relative"}},c={style:{"vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.181ex",role:"img",focusable:"false",viewBox:"0 -511 1000 522","aria-hidden":"true"},p={class:"MathJax",jax:"SVG",style:{position:"relative"}},m={style:{"vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.262ex",height:"1.181ex",role:"img",focusable:"false",viewBox:"0 -511 1000 522","aria-hidden":"true"};function b(k,e){return l(),t("div",null,[e[32]||(e[32]=n("h1",{id:"softwarearchitektur",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#softwarearchitektur"},[n("span",null,"Softwarearchitektur")])],-1)),e[33]||(e[33]=n("h2",{id:"_1-schnittstellen",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_1-schnittstellen"},[n("span",null,"1 Schnittstellen")])],-1)),e[34]||(e[34]=n("p",null,[i("Alltagsgegenstände haben bekannte und wohldefinierte "),n("strong",null,"Schnittstellen"),i(", daher sind diese einfach zu bedienen. Die sogenannten "),n("strong",null,"Interna"),i(" bleiben dabei verborgen und können auch relativ einfach gewechselt werden. Für die Bedienung ist es unerheblich, wie das Objekt tatsächlich funktioniert.")],-1)),n("p",null,[e[2]||(e[2]=i("Schnittstellen definieren ")),e[3]||(e[3]=n("strong",null,"Verträge",-1)),e[4]||(e[4]=i(", es ist keine Verhandlung zwischen Produzent und Konsument mehr notwendig. ")),n("mjx-container",o,[(l(),t("svg",u,e[0]||(e[0]=[n("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[n("g",{"data-mml-node":"math"},[n("g",{"data-mml-node":"mo"},[n("path",{"data-c":"2192",d:"M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"})])])],-1)]))),e[1]||(e[1]=n("mjx-assistive-mml",{unselectable:"on",display:"inline"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("mo",{stretchy:"false"},"→")])],-1))]),e[5]||(e[5]=i()),e[6]||(e[6]=n("strong",null,"Design by Contract (DbC)",-1)),e[7]||(e[7]=i(", nach Bertrand Meyer, 1992"))]),e[35]||(e[35]=r('<ul><li>Bindender Vertrag bei jedem Aufruf <ul><li>Leistung wird erfüllt, falls alle Annahmen erfüllt</li><li>Ansonsten wird Leistung verweigert</li></ul></li><li>Dadurch Sicherstellung der Semantik</li></ul><h3 id="_1-1-information-hiding" tabindex="-1"><a class="header-anchor" href="#_1-1-information-hiding"><span>1.1 Information Hiding</span></a></h3><ul><li>nach David Parnas, 1972</li><li><strong>&quot;Geheimnisprinzip&quot;</strong></li><li>Datenkapselung als mögliche Technik zur Umsetzung</li><li>Funktionalität hinter Schnittstelle verborgen</li><li>Implementierung einfach austauschbar</li></ul><h4 id="_1-1-1-umsetzung-in-java" tabindex="-1"><a class="header-anchor" href="#_1-1-1-umsetzung-in-java"><span>1.1.1 Umsetzung in Java</span></a></h4><ul><li>über <strong>Zugriffsmodifikatoren</strong>: public, private, etc.</li><li>über <strong>Module</strong> (OSGi, seit 2000, oder Java Jigsaw, seit Java 9, 2017)</li><li>über <strong>Annotationen</strong>, Verletzungen der Annotationen werden über Build Tools geprüft</li></ul><h3 id="_1-2-interfaces-in-programmiersprachen" tabindex="-1"><a class="header-anchor" href="#_1-2-interfaces-in-programmiersprachen"><span>1.2 Interfaces in Programmiersprachen</span></a></h3><p>Unterteilung einer Klasse in:</p><ul><li><strong>Schnittstelle und Verhalten</strong>: öffentliche Methoden</li><li><strong>Daten</strong>: Daten die zur Funktion benötigt werden</li></ul><p>Ein Interface (in Java) definiert einen <strong>Vertrag</strong></p><ul><li>Festlegung der Anforderungen durch Methodensignaturen und Dokumentation</li><li>Der Produzent implementiert das Interface</li><li>Der Konsument nutzt das Interface über dessen vordefinierte Methoden</li></ul><p>Alternativ kann (in Java) eine <strong>abstrakte Klasse</strong> eingesetzt werden</p><ul><li>Allerdings keine Mehrfachvererbung</li><li>Dafür leichtere Weiterentwicklung möglich, da Interfaces nach der Veröffentlichung nicht mehr geändert werden können</li></ul><h2 id="_2-solid-prinzipien" tabindex="-1"><a class="header-anchor" href="#_2-solid-prinzipien"><span>2 SOLID-Prinzipien</span></a></h2><p>Es handelt sich um bewährte Prinzipien, die von <strong>Robert C. Martin</strong> zusammengefasst wurden.</p><ul><li>wie Funktionen und Daten <strong>gekoppelt</strong> werden können</li><li>wie Klassen untereinander <strong>angeordnet</strong> werden können</li><li>wie <strong>Schnittstellen</strong> konzipiert werden sollen</li></ul><p>Vorteile</p><ul><li><strong>Erweiterbarkeit</strong>: weniger Wartung durch erweiterbaren/änderbaren Code</li><li><strong>Wiederverwendung</strong>: durch Modularisierung</li><li><strong>Verständlichkeit</strong>: Einarbeitung fällt leichter</li><li><strong>Testbarkeit</strong>: durch Trennung von Schnittstelle und Implementierung werden Tests vereinfacht</li></ul><h3 id="_2-1-single-responsibility-principle" tabindex="-1"><a class="header-anchor" href="#_2-1-single-responsibility-principle"><span>2.1 Single Responsibility Principle</span></a></h3><ul><li>Eine Klasse sollte <strong>nur für einen Akteur relevant</strong> sein</li><li>Gegenbeispiel: God-Class Anti-Pattern</li><li>Möglicher Verstoß bei häufigen Änderungen oder zahlreichen, verschiedenen Imports; Erkennung über Jenkins Git Forensics Plugin, PMD oder CheckStyle</li></ul><h3 id="_2-2-open-closed-principle" tabindex="-1"><a class="header-anchor" href="#_2-2-open-closed-principle"><span>2.2 Open-Closed Principle</span></a></h3><ul><li><strong>Offenheit für Erweiterung</strong> aber <strong>Geschlossenheit für Veränderung</strong></li><li>Erweiterung ohne Veränderung de bestehenden Code, idealerweise einfach Hinzufügung</li><li>Erweiterungen haben keine Auswirkung auf bestehenden Code → keine neue Auslieferung, keine neuen Tests erforderlich</li></ul><h3 id="_2-3-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#_2-3-liskov-substitution-principle"><span>2.3 Liskov Substitution Principle</span></a></h3><ul><li><strong>Subklasse</strong> muss immer <strong>eingesetzt werden können</strong>, wenn Superklasse erwartet wird</li><li>bei einer Schnittstelle muss jede Implementierung eingesetzt werden können</li><li>führt zu einer guten, konsistenten Vererbungshierarchie</li></ul><h3 id="_2-4-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#_2-4-interface-segregation-principle"><span>2.4 Interface Segregation Principle</span></a></h3><ul><li>Verschiedene <strong>Nutzungsarten</strong> eines Bausteins werden über <strong>unterschiedliche Schnittstellen</strong> realisiert</li><li>Entkopplung unterschiedlicer Nutzer</li><li>spezialisierte Schnittstellen</li></ul><h3 id="_2-5-dependency-inversion-principle" tabindex="-1"><a class="header-anchor" href="#_2-5-dependency-inversion-principle"><span>2.5 Dependency Inversion Principle</span></a></h3><ul><li>Im Idealfall: <strong>Abhängigkeiten von Abstraktion</strong> statt von konkreten Implementierungen <ul><li>keine konkrete Klasse referenzieren</li><li>von keiner konkreten Klasse ableiten</li><li>keine konkreten Methoden überschreiben</li></ul></li><li>eigentlich nie vollständig erreichbar</li></ul><h2 id="_3-java-idiome" tabindex="-1"><a class="header-anchor" href="#_3-java-idiome"><span>3 Java Idiome</span></a></h2><p>Idiome sind die <strong>spezifische und typische Verwendung</strong> von Sprachmitteln, also das was sich in der jeweiligen Sprache und Laufzeitumgebung bewährt hat.</p><p>Kommt aus den Sprachwissenschaften und meint dabei eine “typische Art” etwas auszudrücken. Entstehungsweg:</p><ul><li>häufige <strong>Fragestellung</strong> mit <strong>unklarer Implementierung</strong></li><li>parallele Entwicklung verschiedener Lösungen, viele falsch oder unvollständig</li><li>Dokumentation der <strong>&quot;Best Practices&quot;</strong></li><li>Unterstützung durch Entwicklungsumgebung (Code Assistent)</li><li>Bereitstellung von Kurzformen durch <strong>Bibliotheken</strong></li><li>Einzug von Kurzform in die <strong>Sprache</strong></li></ul><h3 id="_3-1-equals-und-hashcode" tabindex="-1"><a class="header-anchor" href="#_3-1-equals-und-hashcode"><span>3.1 equals und hashCode</span></a></h3><ul><li>komplexe Anforderungen</li><li><strong>Algorithmus zum Generieren</strong> schon lange verfügbar</li></ul><h3 id="_3-2-null-handling" tabindex="-1"><a class="header-anchor" href="#_3-2-null-handling"><span>3.2 null Handling</span></a></h3><ul><li>als Default für Objektreferenzen</li><li>weil es einfach umzusetzen war (rückblickend nicht ideal)</li><li>Verwendung bei: optionalen Parametern, ergebnislosen Methoden, ungesetzter Wert</li><li>sollte möglichst vermieden werden, da overhead bei ständiger prüfung auf null</li><li>Alternativen: <ul><li>Verwendung von <strong>Optional</strong> oder <strong>Null Object</strong></li><li>Rückgabe leerer Mengen</li><li>Methoden mit weniger Parametern überladen</li></ul></li><li>Ansonsten Validierung (Objects.requireNonNull) und Annotation (@CheckForNull)</li></ul><h3 id="_3-3-exception-handling" tabindex="-1"><a class="header-anchor" href="#_3-3-exception-handling"><span>3.3 Exception Handling</span></a></h3><p>Laufzeitfehler treten wegen logischer Fehler, fehlerhafter Bedienungen, unberechtigter Benutzungen, temporärer Störungen (Internet etc.) oder Probleme in der Java Runtime (z.B. Speichermangel) auf.</p><p>Je nach dem muss der Fehler im Code ausgebessert, der Benutzer zur Korrektur aufgefordert oder ein neuer Versuch gestartet werden. In Java werden dafür Exceptions geworfen:</p><ul><li>Zwingende Behandlung von Laufzeitfehlern</li><li>Lokalisierung des Fehlers möglich</li><li>Trennung von Programmlogik und Fehlerbehandlung</li></ul><p><strong>Best Practice</strong>: try und catch Blöcke separieren</p><ul><li>Aufruf privater Submethode im try Block, nicht direkt den Code reinschreiben</li><li>Fehlerbehandlung in catch Blöcken</li></ul><p><strong>Best Practice</strong>: Exceptions nicht für Steuerung verwenden</p><ul><li>Bei Exception-Wurf sollte analoge boolesche Prüfmethode vorhanden sein <ul><li>Vor Zugriff auf einen Index <em>get(index)</em> prüfen, ob dieser existiert: z.B. <em>size()</em></li><li>Bei Key-Value mit <em>hasKey(key)</em></li><li>Beim Iterator <em>hasNext()</em></li></ul></li></ul><p>Exceptiontypen:</p><ul><li><strong>checked</strong>: erbt von Exception, aber nicht von RuntimeException, muss deklariert und gefangen werden</li><li><strong>unchecked</strong>: erbt von RuntimeException, muss nicht gefangen werden, dann würde aber das Programm abstürzen</li></ul><p>Unterscheidung in checked und unchecked hat sich in der Praxis nicht bewährt. Generell führen Exceptions schnell zu Spaghetti-Code.</p><p>Verletzung des Information Hiding durch Exceptions, da Implementierungsdetails offenbart werden.</p><p>Umgang mit Exceptions:</p><ul><li>In Geschäftsanwendungen <ul><li><strong>A-Exceptions</strong>: integraler Bestandteil der Schnittstelle, deklariert, beschrieben, beim Aufruf behandelt</li><li><strong>T-Exceptions</strong>: technische Ursache, können nicht aufgezählt werden (Murphy’s Law), können zwar deklariert werden, sollten aber nicht weiter behandelt werden</li></ul></li><li>Bei Fremdbibliotheken <ul><li>oftmals Nutzung von checked Exceptions, langsame Abkehr erkennbar</li><li>Wrapping über Fassade kann sinnvoll sein</li></ul></li></ul><h2 id="_4-patterns" tabindex="-1"><a class="header-anchor" href="#_4-patterns"><span>4 Patterns</span></a></h2><p>Ein Muster ist eine bewährte Lösung für eine häufig wiederkehrende Problemstellung.</p><ul><li>(abstrakte) Wiederverwendung</li><li>dokumentiert bewährte und elegante Lösung</li><li>gemeinsames Vokabular</li><li>einfachere Auswahl von Alternativen</li></ul><p>Patterns können aber auch zur Plage werden:</p><ul><li>nur einsetzen, falls wirklich benötigt (muss Mehrwert bringen)</li><li>Komplexität der Software nimmt zu (mehr Klassen, mehr Methodenaufrufe)</li><li>wichtig zu beachten, wann Pattern nicht eingesetzt werden sollte</li><li>Negativbeispiel Singleton: einfach aber meist unnütz</li></ul><p>Einordnung in Erzeugung, Struktur und Verhalten.</p><h3 id="_4-1-erzeugung" tabindex="-1"><a class="header-anchor" href="#_4-1-erzeugung"><span>4.1 Erzeugung</span></a></h3><p>Im Folgenden die wichtigsten Erzeugung Patterns:</p><h4 id="_4-1-1-builder" tabindex="-1"><a class="header-anchor" href="#_4-1-1-builder"><span>4.1.1 Builder</span></a></h4><p>Das <strong>Builder Pattern</strong> dient der vereinfachten Erzeugung komplexer Objekte durch Auslagerung in eine spezielle Klasse.</p><p>Vorteile</p><ul><li>bessere Erweiterung durch Modularisierung</li><li>einfache Integration und Wiederverwendung</li><li>&quot;zeitlich gestreckte&quot; Konstruktion: Fehlerbehandlung mit anschließender Fortsetzung möglich, keine Wiederholung vorheriger Schritte notwendig</li><li>erleichterte Entwicklung im Team</li></ul><p>Nachteile</p><ul><li>enge Kopplung von Builder, Produkt und beteiligten Klassen</li></ul><h4 id="_4-1-2-factory-method" tabindex="-1"><a class="header-anchor" href="#_4-1-2-factory-method"><span>4.1.2 Factory Method</span></a></h4><p>Das <strong>Factory Method Pattern</strong> dient als Schnittstelle zur Objekterzeugung. Die Entscheidung welche konkrete Klasse genommen wird bleibt in der implementierenden Klasse.</p><p>Vorteile</p><ul><li>gekapselter (also austauschbarer) Konstruktionsprozess</li><li>Default-Implementierungen möglich</li><li>kann sicherstellen, dass immer ein Objekt zurückgegeben wird</li></ul><p>Nachteile</p><ul><li>enge Kopplung an das zu erstellende Produkt</li></ul><h3 id="_4-2-struktur" tabindex="-1"><a class="header-anchor" href="#_4-2-struktur"><span>4.2 Struktur</span></a></h3><p>Im Folgenden die wichtigsten Struktur Patterns:</p><h4 id="_4-2-1-adapter" tabindex="-1"><a class="header-anchor" href="#_4-2-1-adapter"><span>4.2.1 Adapter</span></a></h4><p>Das <strong>Adapter Pattern</strong> macht die Anpassung einer Schnittstelle an eine von Clients erwartete Schnittstelle. Das lässt Klassen zusammenarbeiten, die dazu sonst nicht in der Lage wären.</p><p>Vorteile</p><ul><li>Nutzung vorhandener Bibliotheken ohne sich an deren Schnittstelle anpassen zu müssen</li><li>Entkoppelung von den Details vorhandener Komponenten</li><li>Austausch der Schnittstelle im Adapter einfach möglich</li><li>einzige Abhängigkeit ist Erzeugung des Adapters</li></ul><p>Nachteile</p><ul><li>Zusätzliche Delegation, Performance-Verlust</li><li>scheinbar banale Operationen (z.B. sortieren einer Liste) können unerwartet teuer sein, da Datenstruktur im Hintergrund verborgen ist</li></ul><h4 id="_4-2-2-decorator" tabindex="-1"><a class="header-anchor" href="#_4-2-2-decorator"><span>4.2.2 Decorator</span></a></h4><p>Beim <strong>Decorator Pattern</strong> werden dynamische Ergänzungen um Funktionalität vorgenommen, ohne die Komponente dabei zu ändern.</p><p>Vorteile</p><ul><li>Komposition statt Vererbung → flexiblere Klassen, Modifikation zur Laufzeit</li><li>Komponenten kennen Decorator nicht</li></ul><p>Nachteile</p><ul><li>Eventuell wenig übersichtlich bei vielen ähnlich aussehenden Klassen</li></ul><h4 id="_4-2-3-facade" tabindex="-1"><a class="header-anchor" href="#_4-2-3-facade"><span>4.2.3 Facade</span></a></h4><p>Das <strong>Facade Pattern</strong> dient dem vereinfachten Zugriff auf ein komplexes Subsystem oder eine Menge zusammengehöriger Objekte.</p><p>Vorteile</p><ul><li>Entkoppelung der Clients von den Details des Subsystems</li></ul><p>Nachteile</p><ul><li>kann umgangen werden, da in der Regel nur organisatorisches Mittel, nicht technisches</li><li>Anpassung der Fassade bei Änderung interner Schnittstellen notwendig</li></ul><h3 id="_4-3-verhalten" tabindex="-1"><a class="header-anchor" href="#_4-3-verhalten"><span>4.3 Verhalten</span></a></h3><p>Im Folgenden die wichtigsten Verhalten Patterns:</p><h4 id="_4-3-1-null-object" tabindex="-1"><a class="header-anchor" href="#_4-3-1-null-object"><span>4.3.1 Null Object</span></a></h4><p>Das <strong>Null Object Pattern</strong> umfasst ein Objekt, das &quot;nichts&quot; tut, was aber fachlich und gewollt ist.</p><p>Vorteile</p><ul><li>Verzicht auf Abfragen bzw. Exception-Behandlung</li><li>Konzentration auf Fachlogik</li><li>Code wird leserlicher</li></ul><p>Nachteile</p><ul><li>erheblicher Aufwand bei nachträglicher Umsetzung</li></ul><h4 id="_4-3-2-template-method" tabindex="-1"><a class="header-anchor" href="#_4-3-2-template-method"><span>4.3.2 Template Method</span></a></h4><p>Das <strong>Template Method Pattern</strong> beinhaltet die Struktur eines Algorithmus, wobei einzelne, konkrete Schritte in Unterklassen verlagert werden. Operationen können dabei überschrieben werden, ohne die Struktur des Algorithmus zu ändern.</p><p>Vorteile</p>',100)),n("ul",null,[n("li",null,[e[10]||(e[10]=i('"invertierter Kontrollfluss": Aufruf der Operationen aus der Unterklasse und nicht umgekehrt ')),n("mjx-container",g,[(l(),t("svg",d,e[8]||(e[8]=[n("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[n("g",{"data-mml-node":"math"},[n("g",{"data-mml-node":"mo"},[n("path",{"data-c":"2192",d:"M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"})])])],-1)]))),e[9]||(e[9]=n("mjx-assistive-mml",{unselectable:"on",display:"inline"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("mo",{stretchy:"false"},"→")])],-1))]),e[11]||(e[11]=i(" wichtige Grundlage für Wiederverwendung"))])]),e[36]||(e[36]=r('<h2 id="_5-komponenten" tabindex="-1"><a class="header-anchor" href="#_5-komponenten"><span>5 Komponenten</span></a></h2><p>Merkmale einer <strong>Komponente</strong>:</p><ul><li>importiert und exportiert <strong>Schnittstellen</strong></li><li>verbirgt Implementierung</li><li>wiederverwendbar</li><li>kann andere Komponenten enthalten</li><li><strong>optional</strong>: Versionsnummer, Auslieferungseinheit</li></ul><p>Inhalt:</p><ul><li>Klassen, Interfaces, Datentypen</li><li>Ressourcen (Bilder, Texte, etc.)</li><li>Metadaten (Beschreibung, Version)</li></ul><h3 id="_5-1-umsetzung-in-java" tabindex="-1"><a class="header-anchor" href="#_5-1-umsetzung-in-java"><span>5.1 Umsetzung in Java</span></a></h3><ul><li><strong>Module</strong> mit strikter Zugriffsbeschränkung (OSGi / Java Jigsaw)</li><li><strong>Simple JAR Files</strong></li><li><strong>Java Enterprise Beans</strong></li><li><strong>Spring Components</strong>, Beans</li><li>Custom-made <strong>Plugin System</strong> (z.B. Jenkins)</li></ul><h3 id="_5-2-komponentendesign" tabindex="-1"><a class="header-anchor" href="#_5-2-komponentendesign"><span>5.2 Komponentendesign</span></a></h3><p>Das Komponentendesign kann statisch oder dynamisch sein und definiert die Struktur der Elemente innerhalb einer Komponente.</p><p>Wie bei Interfaces wird eine äußere und eine innere Ebene spezifiziert. Nach außen die Schnittstellen und Beziehungen zu anderen Komponenten. Nach innen die zentralen Klassen und Beziehungen der Klassen untereinander.</p><p>Grundsätze:</p><ul><li><strong>Information Hiding</strong><ul><li>Zugriff über Interfaces</li><li>Daten nur als Kopien herausgeben (Transferobjekte)</li><li>keine Vererbung über Komponentengrenzen</li></ul></li><li><strong>Designentscheidungen</strong><ul><li>Services der Schnittstellen</li><li>Welche Komponente welche Entitäten verwaltet</li><li>Wo und wie Fachdaten exportiert werden können</li></ul></li><li><strong>Kreativität</strong> ist wichtig!</li></ul><h2 id="_6-komponentenstrukturierung" tabindex="-1"><a class="header-anchor" href="#_6-komponentenstrukturierung"><span>6 Komponentenstrukturierung</span></a></h2><p>Aufteilung eines Systems in Komponenten anhand bestimmter Kriterien:</p>',14)),n("ul",null,[e[19]||(e[19]=n("li",null,[n("strong",null,"Separation of Concerns"),n("ul",null,[n("li",null,[i("Gruppierung "),n("strong",null,"nach Verantwortlichkeiten")]),n("li",null,"Unterscheidung in fachliches, technisches, und Mischungen")])],-1)),e[20]||(e[20]=n("li",null,[n("strong",null,"Blutgruppen"),n("ul",null,[n("li",null,"siehe Unterkapitel 6.1 Blutgruppen")])],-1)),n("li",null,[e[18]||(e[18]=n("strong",null,"Kohäsion",-1)),n("ul",null,[e[17]||(e[17]=n("li",null,[i("Zusammenfassung nach "),n("strong",null,"inhaltlichem Zusammenhang")],-1)),n("li",null,[e[14]||(e[14]=i("Bringe zusammen, was zusammen gehört ")),n("mjx-container",h,[(l(),t("svg",c,e[12]||(e[12]=[n("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[n("g",{"data-mml-node":"math"},[n("g",{"data-mml-node":"mo"},[n("path",{"data-c":"2192",d:"M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"})])])],-1)]))),e[13]||(e[13]=n("mjx-assistive-mml",{unselectable:"on",display:"inline"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("mo",{stretchy:"false"},"→")])],-1))]),e[15]||(e[15]=i(" möglichst hohe ")),e[16]||(e[16]=n("strong",null,"Kohäsion",-1))])])]),e[21]||(e[21]=r("<li><strong>Kopplung</strong><ul><li>Ziel: <strong>Minimierung der Abhängigkeiten</strong> und möglichst lose Kopplung</li><li>Kopplung durch: Vererbung, Instanziierung, Parameter, Attribute, Exceptions, Annotationen, etc.</li><li>in Java über <strong>Imports</strong> sichtbar</li><li>zusätzlich Kopplung durch <ul><li><strong>Datenstrukturen</strong>: Datenbank-Tabellen, REST-Schnittstellen, Datei-Formate</li><li><strong>Hardware oder Laufzeitumgebung</strong>: gleiche virtuelle Maschine, gleiches Netzwerksegment</li><li><strong>Zeit</strong>: Reihenfolge, Laufzeit</li></ul></li><li><strong>enge Kopplung</strong> (objektorientiert): arbeitet mit Objektreferenzen</li><li><strong>lose Kopplung</strong> (dienstorientiert): arbeitet mit Werten</li></ul></li><li><strong>Conway’s Law</strong><ul><li>Beeinflusst durch <strong>Organisation eines Unternehmens</strong>, also fachliche/technische Abteilungen, Standorte</li></ul></li><li><strong>Common-Closure Principle (CCP)</strong><ul><li>Zusammengehörigkeit auf Basis <strong>gemeinsamer Änderungen</strong></li><li>was typischerweise gemeinsam geändert wird, gehört zusammen</li><li>Folge von Single Responsibility Principle und Open Closed Principle</li></ul></li><li><strong>Reuse-Release-Equivalence Principle (REP)</strong><ul><li>Zusammengehörigkeit auf Basis <strong>gemeinsamer Release Zeitpunkte</strong></li><li>wenn gemeinsam in ein Release gebündelt werden kann</li></ul></li><li><strong>Common-Reuse Principle (CRP)</strong><ul><li>was <strong>gemeinsam verwendet</strong> wird, kommt in eine Komponente</li><li>umgekehrt: eine andere Komponente sollte möglichst alle Bausteine der Komponente nutzen</li><li>Verallgemeinerung des Interface Segregaion Principle</li><li>Beispiel: Container und zugehörige Iteratoren</li></ul></li>",5))]),e[37]||(e[37]=r('<h3 id="_6-1-blutgruppen" tabindex="-1"><a class="header-anchor" href="#_6-1-blutgruppen"><span>6.1 Blutgruppen</span></a></h3><p>Blutgruppen lassen sich auf Johannes Siedersleben, sd&amp;m, 2004, zurückführen. Dabei wird Anwendung von Technik getrennt. Anwendungscode sollte möglichst nie technischen Code referenzieren. Vermischungen verschlechtern Wartbarkeit, Erweiterbarkeit und Wiederverwendbarkeit.</p><ul><li><strong>0-Komponente</strong><ul><li>unabhängig von Anwendung und Technik</li><li>widerverwendbar</li><li>alleine genommen nutzlos</li></ul></li><li><strong>A-Komponente</strong><ul><li>nur Anwendungslogik</li><li>ganz oder teilweise wiederverwendbar</li></ul></li><li><strong>T-Komponente</strong><ul><li>nur Technik</li><li>manchmal wiederverwendbar</li></ul></li><li><strong>AT-Komponente</strong><ul><li>Anwendungslogik und Technik</li><li>schwer wartbar und kaum wiederverwendbar</li><li>verletzt das Single Responsibility Principle</li></ul></li></ul><p>Ein <strong>Adapter</strong> kann hier helfen</p><ul><li>neue Blutgruppe R</li><li>Transformation zwischen zwei Repräsentationen</li><li>kann oft generiert werden</li></ul><h2 id="_7-systemarchitektur" tabindex="-1"><a class="header-anchor" href="#_7-systemarchitektur"><span>7 Systemarchitektur</span></a></h2><p>Eine Systemarchitektur beschreibt die physische Verteilung einer Anwendung.</p><ul><li>über mehrere Rechner hinweg, kein gemeinsamer Speicher, sondern Nachrichtenaustausch</li><li>aus Sicht des Anwenders “ein System”</li><li>welche Komponente wo läuft und welche Aufgabe übernimmt</li><li>wie die Kommunikation abläuft und was bei einem Teilausfall passiert</li></ul><h3 id="_7-1-client-server-architektur" tabindex="-1"><a class="header-anchor" href="#_7-1-client-server-architektur"><span>7.1 Client Server Architektur</span></a></h3><ul><li>viele Clients, einige wenige Server, synchrone Kommunikation</li><li>verbreitet bei verteilter Nutzung gemeinsamer Daten</li><li>Datenhaltung beim Server, Präsentation bei den Clients, Aufteilung der Logik</li><li>Lastverteilung über Partitionierung oder Replikation</li><li>Klassisch 3-Tier (Client, Anwendung, Datenhaltung), Erweiterung um zusätzliche Schichten mögich: Webserver, Reverse Proxy, Load Balancer, Datawarehouse, SAP, ...</li></ul><h3 id="_7-2-coordinator-worker-architektur" tabindex="-1"><a class="header-anchor" href="#_7-2-coordinator-worker-architektur"><span>7.2 Coordinator Worker Architektur</span></a></h3><p>Koordination der Abarbeitung durch eine Komponente.</p>',12)),n("ul",null,[e[28]||(e[28]=n("li",null,[i("eigentliche Arbeit durch "),n("strong",null,"Reihe gleichartiger Komponenten")],-1)),e[29]||(e[29]=n("li",null,[n("strong",null,"asymmetrische Arbeitsteilung"),i(": ein Coordinator, viele Worker")],-1)),e[30]||(e[30]=n("li",null,[i("Sonderfall "),n("strong",null,'"Leader Election"'),i(": Coordinator wird unter gleichartigen Knoten gewählt, bei Ausfall übernimmt ein anderer")],-1)),n("li",null,[e[27]||(e[27]=i("sehr verbreitet ")),n("ul",null,[n("li",null,[e[24]||(e[24]=i("beliebige Skalierung möglich ")),n("mjx-container",p,[(l(),t("svg",m,e[22]||(e[22]=[n("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[n("g",{"data-mml-node":"math"},[n("g",{"data-mml-node":"mo"},[n("path",{"data-c":"2192",d:"M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"})])])],-1)]))),e[23]||(e[23]=n("mjx-assistive-mml",{unselectable:"on",display:"inline"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("mo",{stretchy:"false"},"→")])],-1))]),e[25]||(e[25]=i(" Verteilung rechenintensiver Aufgaben"))]),e[26]||(e[26]=n("li",null,[n("strong",null,"Ausfallsicherung"),i(": Replika springen bei Bedarf ein")],-1))])]),e[31]||(e[31]=n("li",null,"Anwendung in Jenkins",-1))]),e[38]||(e[38]=r('<h3 id="_7-3-peer-to-peer-architektur" tabindex="-1"><a class="header-anchor" href="#_7-3-peer-to-peer-architektur"><span>7.3 Peer-to-Peer Architektur</span></a></h3><p>Gleichberechtigte Knoten sind über ein Netz verbunden.</p><ul><li>gleichartige Dienste</li><li>symmetrische Arbeitsteilung: bidirektionale Kommunikation, verschieden leistungsstarke Peers, sowohl Anbieter als auch Nutzer</li><li>vor allem bei gemeinsamer Ressourcennutzung</li><li>höchste Ausfallsicherheit, da kein <strong>single point of failure</strong></li><li><strong>Aber</strong>: Sicherheit der verarbeiteten Daten nur schwer zu gewährleisten (keine Kontrolle)</li></ul><h3 id="_7-4-batch-verarbeitung" tabindex="-1"><a class="header-anchor" href="#_7-4-batch-verarbeitung"><span>7.4 Batch-Verarbeitung</span></a></h3><p>Auch &quot;Stapelverarbeitung&quot; genannt.</p><ul><li>Standard bei Verarbeitung großer Datenmengen <ul><li>bspw. zum Quartalsende die Quartalsdaten</li><li>langlaufende Jobs</li><li>stoppen und fortsetzen möglich</li></ul></li><li>u.a. Spring Batch</li></ul><h3 id="_7-5-pipes-und-filter" tabindex="-1"><a class="header-anchor" href="#_7-5-pipes-und-filter"><span>7.5 Pipes und Filter</span></a></h3><ul><li>Verarbeitung auf unabhängigen Knoten (Transformation Eingabe zu Ausgabe)</li><li>Schritte relativ unabhängig voneinander</li><li>Geschwindigkeit höngt am langsamsten Schritt, aber Skalierung der einzelnen Filter leicht möglich</li></ul><h3 id="_7-6-reactive-streams" tabindex="-1"><a class="header-anchor" href="#_7-6-reactive-streams"><span>7.6 Reactive Streams</span></a></h3><ul><li>keine Verarbeitung der Daten als Ganzes, Datenteile sollen sofort verarbeitet werden</li><li><strong>Beispiel</strong>: Video Streaming (asynchrone Streams)</li><li>Pull- oder Push-Ansatz (bei Push steuert ein Processor die Auslastung)</li><li><strong>Problem</strong>: Überlauf, wenn zu schnell gesendet wird</li><li><strong>Reactive Streams in Java</strong>: Steuerung der Austauschgeschwindigkeit, verhindert Blockierung und benötigt keine Pufferung auf Quell-Seite</li></ul><h3 id="_7-7-service-oriented-architecture" tabindex="-1"><a class="header-anchor" href="#_7-7-service-oriented-architecture"><span>7.7 Service Oriented Architecture</span></a></h3><p>Service Bus als standardisierte Schnittstelle, die heterogene Landschaften miteinander verbindet, Verschlüsselung vorgibt und ein Dienstverzeichnis verwaltet.</p><ul><li>Kapselung der Services</li><li>lose Kopplung über (XML) Schnittstellen</li><li>Kopplung im Service Bus</li></ul><h3 id="_7-8-cloud-computing-und-microservices" tabindex="-1"><a class="header-anchor" href="#_7-8-cloud-computing-und-microservices"><span>7.8 Cloud Computing und Microservices</span></a></h3><ul><li>kleine, abgegrenzte Dienste, die unabhängig skaliert werden können</li><li>&quot;Service Discovery&quot; als eigener Dienst</li><li>individuelle Datenhaltungen statt zentralem DB-Server</li><li>Containerisierung und Kommunikation über leichtgewichtiges Protokoll (z.B. HTTP)</li><li>Anpassungen zur Laufzeit möglich: Auslieferung automatisiert über CD, Austausch von Services, einfache Auslagerung möglich</li><li>Das Produkt steht im Vordergrund und wird über den gesamten Lebenszyklus betreut</li><li>Verringerung der Abhängigkeiten</li></ul><h2 id="_8-architekturtests" tabindex="-1"><a class="header-anchor" href="#_8-architekturtests"><span>8 Architekturtests</span></a></h2><p>Statische Analyse ist ein Teilbereich der Statischen Tests (Tests ohne Programmausführung). Statische Analyse mittels:</p><ul><li><strong>Compiler &amp; IDE</strong>: Warnungen</li><li><strong>ErrorProne, CheckStyle, PMD, SpotBugs</strong>: Verletzung von Richtlinien, typische Bugs</li><li><strong>AnimalSniffer</strong>: keine verbotenen APIs (Kompatibilität zu älteren Java-Versionen)</li><li><strong>Maven Enforcer</strong>: unverträgliche Abhängigkeiten</li><li><strong>OWASP Dependency-Check</strong>: Sicherheitslücken</li><li><strong>RevApi</strong>: Abwärtskompatibilität von APIs</li><li><strong>ArchUnit</strong>: Design- und Architekturrichtlinien</li></ul><p>Prüfbare Elemente (nach Carola Lilienthal: &quot;Langlebige Softwarearchitekturen&quot;):</p><ul><li><strong>Modularität</strong>: Klassen und Komponenten</li><li><strong>Hierarchische Struktur</strong>: Schichten und Verantwortung</li><li><strong>Muster Konsistenz</strong>: Klassentypen und Lösungstypen</li></ul><p>Varianten zur Prüfung:</p><ul><li>Manuelle Reviews</li><li>Manuelle Werkzeuge der IDE (Structure101, JArchitect)</li><li>Automatisierte statische Code Analyse Tools <ul><li>mit Source Code: CheckStyle und PMD</li><li>mit Byte Code: ErrorProne und SpotBugs</li></ul></li><li>Automatisierte Testfälle (Jenkins, ArchUnit)</li></ul><h3 id="_8-1-archunit" tabindex="-1"><a class="header-anchor" href="#_8-1-archunit"><span>8.1 ArchUnit</span></a></h3><p>Validierung der Architektur über Testfälle in JUnit 5.</p><ul><li>umfassende vordefinierte Funktionalität <ul><li>Layering</li><li>verbotene Aufrufe</li><li>Sicherheitsrichtlinien, Konventionen, Information Hiding</li><li>vordefinierte Regeln <ul><li>Nur Java Logging</li><li>Kein Joda Time</li><li>Keine generischen Exceptions</li><li>Kein Präfix oder Suffix bei Interfaces</li><li>Schichten- oder Zwiebelarchitektur</li><li>Abhängigkeiten</li><li>Vererbungsstruktur</li><li>Nutzung von Annotationen</li><li>Sichtbarkeiten</li></ul></li></ul></li><li>einlesen relevanter Klassen und ausführen gewünschter Regeln über Fluent API</li><li>Aufbau der Architekturregeln (<strong>Element</strong> that <strong>Predicate</strong> should <strong>Condition</strong>) <ul><li><strong>Element</strong>: Klassen, Methoden, Attribute, etc.</li><li><strong>Prädikat</strong>: Filterung der Menge an Elementen</li><li><strong>Bedingung</strong>: gewünschte Kriterien</li><li>Prädikate und Bedingungen sind wiederverwendbar</li></ul></li><li>Weitere Features <ul><li><strong>Freezing Rules</strong>: bestehender Code wird eingefroren, aber neuer Code muss konform sein</li><li><strong>Architektur-Metriken</strong></li><li><strong>sprechende Fehlermeldungen</strong></li><li><strong>Ignore List</strong> mit erlaubten Verstößen</li></ul></li></ul>',25))])}const v=s(a,[["render",b],["__file","Softwarearchitektur.html.vue"]]),z=JSON.parse('{"path":"/posts/SoSe2024/Softwarearchitektur.html","title":"Softwarearchitektur","lang":"en-US","frontmatter":{"date":"2024-07-18T00:00:00.000Z","author":"Linus Englert","timeline":false,"article":false,"description":"Softwarearchitektur 1 Schnittstellen Alltagsgegenstände haben bekannte und wohldefinierte Schnittstellen, daher sind diese einfach zu bedienen. Die sogenannten Interna bleiben d...","head":[["meta",{"property":"og:url","content":"https://chabbay.github.io/ChabbaYsZusammenfassungen-Blog/posts/SoSe2024/Softwarearchitektur.html"}],["meta",{"property":"og:site_name","content":"Zusammenfassungen"}],["meta",{"property":"og:title","content":"Softwarearchitektur"}],["meta",{"property":"og:description","content":"Softwarearchitektur 1 Schnittstellen Alltagsgegenstände haben bekannte und wohldefinierte Schnittstellen, daher sind diese einfach zu bedienen. Die sogenannten Interna bleiben d..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-13T20:35:40.000Z"}],["meta",{"property":"article:author","content":"Linus Englert"}],["meta",{"property":"article:published_time","content":"2024-07-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-13T20:35:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"Softwarearchitektur\\",\\"description\\":\\"Softwarearchitektur 1 Schnittstellen Alltagsgegenstände haben bekannte und wohldefinierte Schnittstellen, daher sind diese einfach zu bedienen. Die sogenannten Interna bleiben d...\\"}"]]},"headers":[{"level":2,"title":"1 Schnittstellen","slug":"_1-schnittstellen","link":"#_1-schnittstellen","children":[{"level":3,"title":"1.1 Information Hiding","slug":"_1-1-information-hiding","link":"#_1-1-information-hiding","children":[]},{"level":3,"title":"1.2 Interfaces in Programmiersprachen","slug":"_1-2-interfaces-in-programmiersprachen","link":"#_1-2-interfaces-in-programmiersprachen","children":[]}]},{"level":2,"title":"2 SOLID-Prinzipien","slug":"_2-solid-prinzipien","link":"#_2-solid-prinzipien","children":[{"level":3,"title":"2.1 Single Responsibility Principle","slug":"_2-1-single-responsibility-principle","link":"#_2-1-single-responsibility-principle","children":[]},{"level":3,"title":"2.2 Open-Closed Principle","slug":"_2-2-open-closed-principle","link":"#_2-2-open-closed-principle","children":[]},{"level":3,"title":"2.3 Liskov Substitution Principle","slug":"_2-3-liskov-substitution-principle","link":"#_2-3-liskov-substitution-principle","children":[]},{"level":3,"title":"2.4 Interface Segregation Principle","slug":"_2-4-interface-segregation-principle","link":"#_2-4-interface-segregation-principle","children":[]},{"level":3,"title":"2.5 Dependency Inversion Principle","slug":"_2-5-dependency-inversion-principle","link":"#_2-5-dependency-inversion-principle","children":[]}]},{"level":2,"title":"3 Java Idiome","slug":"_3-java-idiome","link":"#_3-java-idiome","children":[{"level":3,"title":"3.1 equals und hashCode","slug":"_3-1-equals-und-hashcode","link":"#_3-1-equals-und-hashcode","children":[]},{"level":3,"title":"3.2 null Handling","slug":"_3-2-null-handling","link":"#_3-2-null-handling","children":[]},{"level":3,"title":"3.3 Exception Handling","slug":"_3-3-exception-handling","link":"#_3-3-exception-handling","children":[]}]},{"level":2,"title":"4 Patterns","slug":"_4-patterns","link":"#_4-patterns","children":[{"level":3,"title":"4.1 Erzeugung","slug":"_4-1-erzeugung","link":"#_4-1-erzeugung","children":[]},{"level":3,"title":"4.2 Struktur","slug":"_4-2-struktur","link":"#_4-2-struktur","children":[]},{"level":3,"title":"4.3 Verhalten","slug":"_4-3-verhalten","link":"#_4-3-verhalten","children":[]}]},{"level":2,"title":"5 Komponenten","slug":"_5-komponenten","link":"#_5-komponenten","children":[{"level":3,"title":"5.1 Umsetzung in Java","slug":"_5-1-umsetzung-in-java","link":"#_5-1-umsetzung-in-java","children":[]},{"level":3,"title":"5.2 Komponentendesign","slug":"_5-2-komponentendesign","link":"#_5-2-komponentendesign","children":[]}]},{"level":2,"title":"6 Komponentenstrukturierung","slug":"_6-komponentenstrukturierung","link":"#_6-komponentenstrukturierung","children":[{"level":3,"title":"6.1 Blutgruppen","slug":"_6-1-blutgruppen","link":"#_6-1-blutgruppen","children":[]}]},{"level":2,"title":"7 Systemarchitektur","slug":"_7-systemarchitektur","link":"#_7-systemarchitektur","children":[{"level":3,"title":"7.1 Client Server Architektur","slug":"_7-1-client-server-architektur","link":"#_7-1-client-server-architektur","children":[]},{"level":3,"title":"7.2 Coordinator Worker Architektur","slug":"_7-2-coordinator-worker-architektur","link":"#_7-2-coordinator-worker-architektur","children":[]},{"level":3,"title":"7.3 Peer-to-Peer Architektur","slug":"_7-3-peer-to-peer-architektur","link":"#_7-3-peer-to-peer-architektur","children":[]},{"level":3,"title":"7.4 Batch-Verarbeitung","slug":"_7-4-batch-verarbeitung","link":"#_7-4-batch-verarbeitung","children":[]},{"level":3,"title":"7.5 Pipes und Filter","slug":"_7-5-pipes-und-filter","link":"#_7-5-pipes-und-filter","children":[]},{"level":3,"title":"7.6 Reactive Streams","slug":"_7-6-reactive-streams","link":"#_7-6-reactive-streams","children":[]},{"level":3,"title":"7.7 Service Oriented Architecture","slug":"_7-7-service-oriented-architecture","link":"#_7-7-service-oriented-architecture","children":[]},{"level":3,"title":"7.8 Cloud Computing und Microservices","slug":"_7-8-cloud-computing-und-microservices","link":"#_7-8-cloud-computing-und-microservices","children":[]}]},{"level":2,"title":"8 Architekturtests","slug":"_8-architekturtests","link":"#_8-architekturtests","children":[{"level":3,"title":"8.1 ArchUnit","slug":"_8-1-archunit","link":"#_8-1-archunit","children":[]}]}],"git":{"createdTime":1736800540000,"updatedTime":1736800540000,"contributors":[{"name":"Linus Englert","username":"Linus Englert","email":"linus@englert.cloud","commits":1,"url":"https://github.com/Linus Englert"}]},"readingTime":{"minutes":7.57,"words":2271},"filePathRelative":"posts/SoSe2024/Softwarearchitektur.md","localizedDate":"July 18, 2024","excerpt":"\\n<h2>1 Schnittstellen</h2>\\n<p>Alltagsgegenstände haben bekannte und wohldefinierte <strong>Schnittstellen</strong>, daher sind diese einfach zu bedienen. Die sogenannten <strong>Interna</strong> bleiben dabei verborgen und können auch relativ einfach gewechselt werden. Für die Bedienung ist es unerheblich, wie das Objekt tatsächlich funktioniert.</p>","autoDesc":true}');export{v as comp,z as data};
